aspect ConstraintGeneration {

  private Collection<Formula> Program.collectConstraint() {
    Collection<Formula> result = new LinkedList<Formula>();
    for (CompilationUnit unit: getCompilationUnitList()) {
      result.addAll(unit.collectConstraint());
    }
    return result;
  }

  public Collection<Formula> CompilationUnit.collectConstraint() {
    Collection<Formula> result = new LinkedList<Formula>();
    for (TypeDecl type: getTypeDeclList()) {
      result.addAll(type.collectConstraint());
    }
    return result;
  }

  public Collection<Formula> TypeDecl.collectConstraint() { return Collections.emptyList(); }

  public Collection<Formula> ClassDecl.collectConstraint() {
    Collection<Formula> result = new LinkedList<Formula>();
    if (hasSuperClass()) {
      result.add(getSuperClass().constraint().get());
    }
    for (BodyDecl bodyDecl: getBodyDeclList()) {
      result.addAll(bodyDecl.collectConstraint());
    }
    return result;
  }

  public Collection<Formula> BodyDecl.collectConstraint() { return gatherConstraint(); }

  public Collection<Formula> MethodDecl.collectConstraint() {
    if (varListSet.size() > 0) {
      Collection<Formula> result = new LinkedList<Formula>();
      for (java.util.List<Integer> varList: varListSet) {
        for (Formula constraint: gatherConstraint()) {
          result.add(constraint.replace(this, varList));
        }
      }
      result.addAll(gatherConstraint());
      return result;
    } else {
      return gatherConstraint();
    }
  }

  coll LinkedList<Formula> BodyDecl.gatherConstraint() root BodyDecl;

  Expr contributes each gatherConstraint() to BodyDecl.gatherConstraint();

  syn Collection<Formula> Expr.gatherConstraint()
    = constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

  eq Dot.gatherConstraint() = Collections.emptyList();

  Stmt contributes each gatherConstraint() to BodyDecl.gatherConstraint();

  syn Collection<Formula> Stmt.gatherConstraint()
    = constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

  Declarator contributes each gatherConstraint() to BodyDecl.gatherConstraint();

  syn Collection<Formula> Declarator.gatherConstraint()
    = constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

  /** monomorphic constraint generation

  coll LinkedList<Formula> Program.collectConstraint() root Program;

  Expr contributes each collectConstraint() to Program.collectConstraint();

  syn Collection<Formula> Expr.collectConstraint() =
    constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

  eq Dot.collectConstraint() = Collections.emptyList();

  Stmt contributes each collectConstraint() to Program.collectConstraint();

  syn Collection<Formula> Stmt.collectConstraint() =
    constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

  Declarator contributes each collectConstraint() to Program.collectConstraint();

  syn Collection<Formula> Declarator.collectConstraint() =
    constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();
  */

}

aspect VersionInference {

  public final java.util.List<Map<Integer,TypeDecl>> Program.solutions = new ArrayList();

  public int Program.solveConstraint() {
    long start = System.nanoTime();
    Collection<Formula> constraints = collectConstraint();
    constraintGenTime += System.nanoTime() - start;

    Model model = new Model("Inference");
    IntVar[] vars = new IntVar[infVarCount];

    for (int i = 0; i < infVarCount; i++) {
      vars[i] = infTypeMap.size() > 1
        ? model.intVar("v" + i, 0, infTypeMap.size() - 1)
        : model.intVar("v" + i, 0);
    }

    for (Formula constraint: constraints) {
      constraint.post(model, vars).post();
    }

    start = System.nanoTime();
    java.util.List<Solution> solverSolutions = model.getSolver().findAllSolutions();
    solvingTime += System.nanoTime() - start;

    for (Solution solverSolution: solverSolutions) {
      Map<Integer,TypeDecl> solution = new HashMap();
      for (int i = 0; i < infVarCount; i++) {
        Integer infType = solverSolution.getIntVal(vars[i]);
        solution.put(i, intToType(infType));
      }
      solutions.add(solution);
      System.err.println(printSolution(solution));
    }

    System.err.println(solutions.size());

    return solutions.size() > 0 ? 0 : 4;
  }

}