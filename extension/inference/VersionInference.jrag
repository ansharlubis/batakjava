aspect ConstraintGeneration {

  coll LinkedList<Formula> Program.collectConstraint() root Program;

  Expr contributes each collectConstraint() to Program.collectConstraint();

  syn Collection<Formula> Expr.collectConstraint() =
    constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

  eq Dot.collectConstraint() = Collections.emptyList();

  Stmt contributes each collectConstraint() to Program.collectConstraint();

  syn Collection<Formula> Stmt.collectConstraint() =
    constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

  Declarator contributes each collectConstraint() to Program.collectConstraint();

  syn Collection<Formula> Declarator.collectConstraint() =
    constraint().isPresent() ? constraint().get().toList() : Collections.emptyList();

}

aspect VersionInference {

  public final java.util.List<Map<Integer,TypeDecl>> Program.solutions = new ArrayList();

  public int Program.solveConstraint() {
    long start = System.nanoTime();
    LinkedList<Formula> constraints = collectConstraint();
    constraintGenTime += System.nanoTime() - start;

    Model model = new Model("Inference");
    IntVar[] vars = new IntVar[infVarCount];

    for (int i = 0; i < infVarCount; i++) {
      vars[i] = infTypeMap.size() > 1
        ? model.intVar("v" + i, 0, infTypeMap.size() - 1)
        : model.intVar("v" + i, 0);
    }

    for (Formula constraint: constraints) {
      // System.err.println(constraint);
      constraint.post(model, vars).post();
    }

    start = System.nanoTime();
    java.util.List<Solution> solverSolutions = model.getSolver().findAllSolutions();
    solvingTime += System.nanoTime() - start;

    for (Solution solverSolution: solverSolutions) {
      Map<Integer,TypeDecl> solution = new HashMap();
      for (int i = 0; i < infVarCount; i++) {
        Integer infType = solverSolution.getIntVal(vars[i]);
        solution.put(i, intToType(infType));
      }
      // System.out.println(solution);
      solutions.add(solution);
    }

    return solutions.size() > 0 ? 0 : 4;
  }

}

aspect LatestSolution {

  public Optional<Map<Integer,TypeDecl>> Program.laterSolution(
      Map<Integer,TypeDecl> sol1, Map<Integer,TypeDecl> sol2) {
    boolean start = false;
    boolean left = false;
    Optional<Map<Integer,TypeDecl>> result = Optional.empty();
    for (Integer key: infVarMap.keySet()) {
      ASTNode node = infVarMap.get(key);
      if (node instanceof TypeAccess && node.parent instanceof ClassInstanceExpr) {
        Integer leftVer = Integer.valueOf(sol1.get(key).version());
        Integer rightVer = Integer.valueOf(sol2.get(key).version());
        if (start) {
          if (left && rightVer > leftVer) {
            return Optional.empty();
          }
          if (!left && leftVer > rightVer) {
            return Optional.empty();
          }
        } else {
          start = true;
          if (leftVer >= rightVer) {
            left = true;
            result = Optional.of(sol1);
          } else {
            result = Optional.of(sol2);
          }
        }
      }
    }
    return result;
  }

  public Optional<Map<Integer,TypeDecl>> Program.latestSolution() {
    Optional<Map<Integer,TypeDecl>> result = Optional.of(solutions.get(0));
    if (solutions.size() > 1) {
      for (int i = 1; i < solutions.size(); i++) {
        if (result.isPresent()) {
          result = laterSolution(result.get(), solutions.get(i));
        } else {
          return result;
        }
      }
    }
    return result;
  }

}