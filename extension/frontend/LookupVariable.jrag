aspect VariableScope {

  /**
   *  Lookup variable needs to keep track where the variable is located
   *  because constraints have to be put on the enclosing class if the
   *  variable is an inherited field.
   *
   *  If the key is an unknown type, then the it is not a field, but
   *  either a parameter or a local variable, hence no tracing for
   *  constraint is needed.
   */
  inh Map<TypeDecl, SimpleSet<Variable>> Expr.verLookupVariable(String name);

  eq Program.getChild().verLookupVariable(String name) = new HashMap();

  inh Map<TypeDecl,SimpleSet<Variable>> TypeDecl.verLookupVariable(String name);

  eq TypeDecl.getBodyDecl(int i).verLookupVariable(String name) {
    SimpleSet<Variable> list = verMemberFields(name);
    TypeDecl thisType = this;
    if (!list.isEmpty()) {
      return new HashMap<TypeDecl,SimpleSet<Variable>>() {{
        put(thisType, list);
      }};
    }
    // No nested classes, this probably end up empty
    Map<TypeDecl, SimpleSet<Variable>> map = verLookupVariable(name);
    for (TypeDecl type: map.keySet()) {
      map.replace(type, removeInstanceVariables(map.get(type)));
    }
    return map;
  }

  inh Map<TypeDecl,SimpleSet<Variable>> BodyDecl.verLookupVariable(String name);

  eq MethodDecl.getBlock().verLookupVariable(String name) {
    // Check parameter
    SimpleSet<Variable> result = parameterDeclaration(name);
    if (!result.isEmpty()) {
      return new HashMap<TypeDecl, SimpleSet<Variable>>() {{
        put(unknownType(), result);
      }};
    }
    return verLookupVariable(name);
  }

  eq MethodDecl.getParameter().verLookupVariable(String name) =
    new HashMap<TypeDecl, SimpleSet<Variable>>() {{
      put(unknownType(), parameterDeclaration(name));
    }};

  eq ConstructorDecl.getBlock().verLookupVariable(String name) {
    // Check parameter
    SimpleSet<Variable> result = parameterDeclaration(name);
    TypeDecl type = hostType();
    if (!result.isEmpty()) {
      return new HashMap<TypeDecl,SimpleSet<Variable>>() {{
        put(type, result);
      }};
    }
    return verLookupVariable(name);
  }

  eq ConstructorDecl.getParsedConstructorInvocation().verLookupVariable(String name) {
    // Check parameter
    SimpleSet<Variable> result = parameterDeclaration(name);
    TypeDecl type = hostType();
    if (!result.isEmpty()) {
      return new HashMap<TypeDecl,SimpleSet<Variable>>() {{
        put(type, result);
      }};
    }
    return verLookupVariable(name);
  }

  eq ConstructorDecl.getImplicitConstructorInvocation().verLookupVariable(String name) {
    // Check parameter
    SimpleSet<Variable> result = parameterDeclaration(name);
    TypeDecl hostType = hostType();
    if (!result.isEmpty()) {
      return new HashMap<TypeDecl,SimpleSet<Variable>>() {{
        put(hostType, result);
      }};
    }

    Map<TypeDecl, SimpleSet<Variable>> map = verLookupVariable(name);
    for (TypeDecl type: map.keySet()) {
      SimpleSet<Variable> newSet = emptySet();
      for (Variable v: map.get(type)) {
        if (!hostType().verMemberFields(name).contains(v) || v.isStatic()) {
          newSet = newSet.add(v);
        }
      }
      map.replace(type, newSet);
    }
    return map;
  }

  eq ConstructorDecl.getParameter().verLookupVariable(String name)
    = new HashMap<TypeDecl, SimpleSet<Variable>>() {{ put(hostType(), parameterDeclaration(name)); }};

  inh Map<TypeDecl,SimpleSet<Variable>> Stmt.verLookupVariable(String name);

  eq VarDeclStmt.getDeclarator(int index).verLookupVariable(String name) {
    TypeDecl type = hostType().unknownType();
    for (int i = index - 1; i >= 0; i -= 1) {
      if (getDeclarator(i).declaresVariable(name)) {
        Map<TypeDecl, SimpleSet<Variable>> map = new HashMap();
        map.put(type, ASTNode.<Variable>emptySet().add(getDeclarator(i)));
        return map;
      }
    }
    return verLookupVariable(name);
  }

  inh Map<TypeDecl,SimpleSet<Variable>> Block.verLookupVariable(String name);

  eq Block.getStmt(int index).verLookupVariable(String name) {
    VariableDeclarator v = localVariableDeclaration(name);
    TypeDecl type = hostType().unknownType();
    if (v != null && declaredBeforeUse(v, index)) {
      return new HashMap<TypeDecl, SimpleSet<Variable>>() {{
        put(type, ASTNode.<Variable>emptySet().add(v));
      }};
    }
    return verLookupVariable(name);
  }

  inh Map<TypeDecl,SimpleSet<Variable>> CatchClause.verLookupVariable(String name);

  eq CatchClause.getBlock().verLookupVariable(String name) {
    SimpleSet<Variable> result = parameterDeclaration(name);
    TypeDecl type = program().unknownType();
    if (!result.isEmpty()) {
      return new HashMap<TypeDecl, SimpleSet<Variable>>() {{
        put(type, result);
      }};
    }
    return verLookupVariable(name);
  }

  inh Map<TypeDecl,SimpleSet<Variable>> ForStmt.verLookupVariable(String name);

  eq ForStmt.getInitStmt(int index).verLookupVariable(String name) {
    TypeDecl type = hostType().unknownType();
    for (int i = index - 1; i >= 0; i -= 1) {
      VariableDeclarator decl = getInitStmt(i).variableDeclaration(name);
      if (decl != null) {
        return new HashMap<TypeDecl,SimpleSet<Variable>>() {{
          put(type, ASTNode.<Variable>emptySet().add(decl));
        }};
      }
    }
    return verLookupVariable(name);
  }

  eq ForStmt.getCondition().verLookupVariable(String name) = verLocalLookup(name);

  eq ForStmt.getUpdateStmt().verLookupVariable(String name) = verLocalLookup(name);

  eq ForStmt.getStmt().verLookupVariable(String name) = verLocalLookup(name);

  syn lazy Map<TypeDecl,SimpleSet<Variable>> ForStmt.verLocalLookup(String name) {
    TypeDecl type = hostType().unknownType();
    VariableDeclarator v = localVariableDeclaration(name);
    if (v != null) {
      return new HashMap<TypeDecl,SimpleSet<Variable>>() {{
        put(type, ASTNode.<Variable>emptySet().add(v));
      }};
    }
    return verLookupVariable(name);
  }

  eq MethodAccess.getChild().verLookupVariable(String name) = unqualifiedScope().verLookupVariable(name);
  eq ConstructorAccess.getArg().verLookupVariable(String name) = unqualifiedScope().verLookupVariable(name);
  eq SuperConstructorAccess.getArg().verLookupVariable(String name) = unqualifiedScope().verLookupVariable(name);
  eq ArrayAccess.getExpr().verLookupVariable(String name) = unqualifiedScope().verLookupVariable(name);
  eq ArrayTypeWithSizeAccess.getExpr().verLookupVariable(String name) = unqualifiedScope().verLookupVariable(name);
  eq ClassInstanceExpr.getArg().verLookupVariable(String name) = unqualifiedScope().verLookupVariable(name);
  eq Dot.getRight().verLookupVariable(String name) = getLeft().verQualifiedLookupVariable(name);

  eq ParseName.verQualifiedLookupVariable(String name) = new HashMap<TypeDecl,SimpleSet<Variable>>();

  /**
   *  Lookup variable on dot expressions eventually depends
   *  on the constraint of the previous access.
   */
  syn Map<TypeDecl, SimpleSet<Variable>> Expr.verQualifiedLookupVariable(String name) {
    Map<TypeDecl, SimpleSet<Variable>> map = new HashMap();
    for (TypeDecl type: typeSet()) {
      if (type.accessibleFrom(hostType())) {
        map.put(type, keepAccessibleFields(type.verMemberFields(name)));
      }
    }
    return map;
  }

  eq PackageAccess.verQualifiedLookupVariable(String name) = new HashMap();

  eq TypeAccess.verQualifiedLookupVariable(String name) {
    Map<TypeDecl, SimpleSet<Variable>> map = new HashMap();
    for (TypeDecl type: typeSet()) {
      if (type.accessibleFrom(hostType())) {
        SimpleSet<Variable> decls = type.verMemberFields(name);
        decls = keepAccessibleFields(decls);
        if (type.isClassDecl()) {
          decls = removeInstanceVariables(decls);
        }
        map.put(type, decls);
      }
    }
    return map;
  }

}

aspect Fields {

  syn lazy SimpleSet<Variable> TypeDecl.verLocalFields(String name) =
    verLocalFieldsMap().containsKey(name)
    ? verLocalFieldsMap().get(name)
    : ASTNode.<Variable>emptySet();

  syn lazy Map<String, SimpleSet<Variable>> TypeDecl.verLocalFieldsMap() {
    Map<String, SimpleSet<Variable>> map = new HashMap();
    for (BodyDecl decl: getBodyDeclList()) {
      if (decl instanceof FieldDecl) {
        for (FieldDeclarator field: ((FieldDecl) decl).getDeclaratorList()) {
          putSimpleSetElement(map, field.uncompiledName(), field);
        }
      }
    }
    return map;
  }

  syn lazy SimpleSet<Variable> TypeDecl.verMemberFields(String name) = localFields(name);

  eq ClassDecl.verMemberFields(String name) {
    SimpleSet<Variable> fields = verLocalFields(name);
    if (!fields.isEmpty()) {
      return fields;
    }
    for (TypeDecl superType: superclassSet()) {
      for (Variable decl: superType.verMemberFields(name)) {
        if (!decl.isPrivate() && decl.accessibleFrom(this)
            && !fields.contains(decl)) {
          fields = fields.add(decl);
        }
      }
    }
    for (InterfaceDecl iface: superInterfaces()) {
      for (Variable decl: iface.memberFields(name)) {
        if (!decl.isPrivate() && decl.accessibleFrom(this)) {
          fields = fields.add(decl);
        }
      }
    }
    return fields;
  }

}

aspect Variables {

  /**
   *  Field name in compiled class may have version attached,
   *  making it incompatible with name being looked up.
   */
  syn String Declarator.uncompiledName() {
    if (hostType().isCompiled()) {
      String[] splitName = getID().split("\\$");
      if (splitName.length > 1) {
        String[] splitClass = splitName[1].split("_");
        if (splitClass[splitClass.length - 2].equals("ver")) {
          return splitName[0];
        }
      }
    }
    return getID();
  }

}