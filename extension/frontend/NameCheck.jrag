aspect NameCheck {

  /**
   *  TODO: More type checks can be added
   */

  /**
   *  Check whether an applicable constructor is available
   */
  ClassInstanceExpr contributes each constraintProblems() to CompilationUnit.verProblems();

  syn Collection<Problem> ClassInstanceExpr.constraintProblems() {
    Collection<Problem> problems = new LinkedList();
    SimpleSet<TypeDecl> typeSet = typeSet();
    for (TypeDecl type: typeSet) {
      if (!type.isClassDecl()) {
        problems.add(errorf("*** Can only instantiate classes, which %s is not", type.typeName()));
      }
    }
    boolean flag = false;
    for (Expr arg: getArgList()) {
      if (!arg.constraint().isPresent()) {
        flag = true;
      }
    }
    if (flag || !constraint().isPresent()) {
      problems.add(errorf("no candidate constructor found for %s", prettyPrint()));
    }
    return problems;
  }

  /**
   *  Check whether an applicable method is available
   */
  MethodAccess contributes each constraintProblems() to CompilationUnit.verProblems();

  syn Collection<Problem> MethodAccess.constraintProblems() {
    Collection<Problem> problems = new LinkedList();
    boolean flag = true;
    for (Expr arg: getArgList()) {
      if (!arg.constraint().isPresent()) { flag = false; }
    }
    if (flag && !constraint().isPresent()) {
      problems.add(errorf("no candidate method %s found", prettyPrint()));
    }
    return problems;
  }

  /**
   *  Check whether an applicable field/var can be found
   */
  VarAccess contributes each constraintProblems() to CompilationUnit.verProblems();

  syn Collection<Problem> VarAccess.constraintProblems() {
    Collection<Problem> problems = new LinkedList();
    if (!constraint().isPresent()) {
      problems.add(errorf("no variable %s found", prettyPrint()));
    }
    return problems;
  }

  /**
   *  Check whether the selection versions apply for the type access
   */
  VersionTypeAccess contributes each constraintProblems() to CompilationUnit.verProblems();

  syn Collection<Problem> VersionTypeAccess.constraintProblems() {
    Collection<Problem> problems = new LinkedList();
    java.util.List<String> strings = new ArrayList<String>();
    for (String ver: versions()) {
      boolean flag = true;
      for (TypeDecl type: typeSet()) {
        if (type.version().equals(ver)) {
          flag = false;
        }
      }
      if (flag) {
        strings.add(ver);
      }
    }
    if (strings.size() > 0) {
      problems.add(errorf("version(s) %s not found in %s", String.join(", ", strings), prettyPrint()));
    }
    return problems;
  }
}