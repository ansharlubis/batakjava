aspect AccessTypes {

  eq VersionTypeAccess.isTypeAccess() = true;

}

aspect TypeAnalysis {

  /**
   *  A compilation unit is an overview unit if
   *  it only has one class and that class is an overview.
   */
  syn lazy boolean CompilationUnit.isOverviewUnit() =
    getNumTypeDecl() == 1 && getTypeDecl(0).isOverview();

  /**
   *  A class is an overview by searching for
   *  the field BATAKJAVACLASS.
   */
  syn lazy boolean TypeDecl.isOverview() = false;

  eq ClassDecl.isOverview() {
    for (BodyDecl bodyDecl: getBodyDeclList()) {
      if (bodyDecl instanceof FieldDecl) {
        FieldDecl decl = (FieldDecl) bodyDecl;
        if (decl.getNumDeclarator() == 1 &&
            decl.getDeclarator(0).getID().equals("BATAKJAVACLASS")) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   *  A class is compiled if its name contains 'ver'.
   */
  syn boolean TypeDecl.isCompiled() = false;

  eq ClassDecl.isCompiled() {
    String[] splitName = name().split("\\$");
    String[] splitPrefix = splitName[0].split("_");
    return splitPrefix.length > 2 && splitPrefix[splitPrefix.length - 2].equals("ver");
  }

  /**
   *  A class is uncompiled if its host version is not null.
   */
  syn lazy boolean TypeDecl.isUncompiled() = false;
  eq ClassDecl.isUncompiled() = !isOverview() && (hostVersion() != null);

  /**
   *  Get the set of type from constraint
   */
  protected SimpleSet<TypeDecl> Expr.constraintToTypeSet() {
    SimpleSet<TypeDecl> typeSet = emptySet();
    Optional<Formula> constraint = constraint();
    if (constraint.isPresent()) {
      for (Integer typeInt: constraint.get().getTypeInt(infVar())) {
        typeSet = typeSet.add(intToType(typeInt));
      }
    }
    return typeSet;
  }

  /**
   *  Find the set of type for an expression
   *  Treat an empty set as replacement for unknown type
   */
  syn SimpleSet<TypeDecl> Expr.typeSet() = this.<TypeDecl>emptySet().add(type());

  eq Access.typeSet() = emptySet();
  eq TypeAccess.typeSet() = declSet();

  eq ArrayAccess.typeSet() {
    SimpleSet<TypeDecl> types = emptySet();
    if (isQualified()) {
      for (TypeDecl qualifierType: qualifier().typeSet()) {
        types = types.add(qualifierType.componentType());
      }
    }
    return types;
  }

  // A version access returns the type set of the qualifier expression
  eq VersionAccess.typeSet() = qualifier().typeSet();

  // A version type access returns the type set of the qualifier type access
  eq VersionTypeAccess.typeSet() = getTypeAccess().typeSet();

  eq ClassInstanceExpr.typeSet() = hasTypeDecl() ? this.<TypeDecl>emptySet().add(getTypeDecl()) : getAccess().typeSet();
  eq Dot.typeSet() = lastAccess().typeSet();
  eq ParTypeAccess.typeSet() = this.<TypeDecl>emptySet().add(type());   // only for Java classes
  eq ClassAccess.typeSet() = this.<TypeDecl>emptySet().add(type());
  eq DiamondAccess.typeSet() = this.<TypeDecl>emptySet().add(type());

  eq MethodAccess.typeSet() = constraintToTypeSet();
  eq VarAccess.typeSet() = constraintToTypeSet();
  eq ThisAccess.typeSet() = this.<TypeDecl>emptySet().add(type());

  eq CastExpr.typeSet() = getTypeAccess().typeSet();

  syn SimpleSet<TypeDecl> FieldDecl.typeSet() = getTypeAccess().typeSet();

  syn lazy SimpleSet<TypeDecl> MethodDecl.typeSet() = getTypeAccess().typeSet();

  syn lazy SimpleSet<TypeDecl> Variable.typeSet();

  eq ParameterDeclaration.typeSet() = getTypeAccess().typeSet();
  eq Declarator.typeSet() = getTypeAccess().typeSet();
  eq CatchParameterDeclaration.typeSet() = emptySet();
  eq EnumConstant.typeSet() = emptySet();
  eq InferredParameterDeclaration.typeSet() = emptySet();

  inh lazy SimpleSet<TypeDecl> ArrayInit.declTypeSet();
  eq Program.getChild(int i).declTypeSet() = emptySet();
  eq FieldDecl.getDeclarator().declTypeSet() = emptySet();
  eq VarDeclStmt.getDeclarator().declTypeSet() = emptySet();

  eq Declarator.getInit().declTypeSet() = typeSet();
  eq ArrayCreationExpr.getArrayInit().declTypeSet() = typeSet();
  eq ArrayInit.getInit().declTypeSet() {
    SimpleSet<TypeDecl> types = emptySet();
    for (TypeDecl comp: declTypeSet()) {
      types = types.add(comp.componentType());
    }
    return types;
  }

  eq ArrayInit.typeSet() = declTypeSet();

}

aspect SuperClasses {

  public SimpleSet<TypeDecl> ClassDecl.superclassSet() {
    if (isObject()) {
      return emptySet();
    } else if (hasSuperClass()) {
      return getSuperClass().typeSet();
    } else {
      return typeObject();
    }
  }

  public boolean SuperConstructorAccess.classHasSuperAccess() {
    TypeDecl type = hostType();
    if (type instanceof ClassDecl && ((ClassDecl) type).hasSuperClass()) {
      return true;
    }
    return false;
  }

}

aspect TypeConversion {

  /**
   *  Check if this is a subtype of type, while also
   *  keeping track of constraint for super type access.
   */
  syn Optional<Formula> TypeDecl.verMethodInvocationConversionTo(TypeDecl type) {
    if (verIdentityConversionTo(type).isPresent()) {
      return verIdentityConversionTo(type);
    }
    if (verWideningConversionTo(type).isPresent()) {
      return verWideningConversionTo(type);
    }
    return Optional.empty();
  }

  syn Optional<Formula> TypeDecl.verCastingConversionTo(TypeDecl type) {
    if (verIdentityConversionTo(type).isPresent()) {
      return verIdentityConversionTo(type);
    }
    if (verWideningConversionTo(type).isPresent()) {
      return verWideningConversionTo(type);
    }
    if (verNarrowingConversionTo(type).isPresent()) {
      return verNarrowingConversionTo(type);
    }
    return Optional.empty();
  }

  syn Optional<Formula> TypeDecl.verIdentityConversionTo(TypeDecl type) =
    this == type ? Optional.of(new Formula()) : Optional.empty();

  syn Optional<Formula> TypeDecl.verWideningConversionTo(TypeDecl type) = verInstanceOf(type);

  syn Optional<Formula> TypeDecl.verAssignConversionTo(TypeDecl type, Expr expr) {
    if (verIdentityConversionTo(type).isPresent()) {
      return verIdentityConversionTo(type);
    }
    if (verWideningConversionTo(type).isPresent()) {
      return verWideningConversionTo(type);
    }
    boolean sourceIsConstant = expr != null ? expr.isConstant() : false;
    if (sourceIsConstant && (isInt() || isChar() || isShort() || isByte())
        && (type.isByte() || type.isShort() || type.isChar()) && narrowingConversionTo(type)
        && expr.representableIn(type)) {
      return Optional.of(new Formula());
    }
    return Optional.empty();
  }

  syn Optional<Formula> TypeDecl.verNarrowingConversionTo(TypeDecl type) = verInstanceOf(type);

  eq PrimitiveType.verNarrowingConversionTo(TypeDecl type) =
    type.instanceOf(this) ? Optional.of(new Formula()) : Optional.empty();

  eq ShortType.verNarrowingConversionTo(TypeDecl type) =
    type.isByte() || type.isChar() ? Optional.of(new Formula()) : Optional.empty();

  eq CharType.verNarrowingConversionTo(TypeDecl type) =
    type.isByte() || type.isShort() ? Optional.of(new Formula()) : Optional.empty();

  eq ByteType.verNarrowingConversionTo(TypeDecl type) =
    type.isChar() ? Optional.of(new Formula()) : Optional.empty();

  eq ReferenceType.verNarrowingConversionTo(TypeDecl type) {
    if (type.verInstanceOf(this).isPresent()) {
      return type.verInstanceOf(this);
    }
    if (isClassDecl() && !getModifiers().isFinal() && type.isInterfaceDecl()) {
      return Optional.of(new Formula());
    }
    if (isInterfaceDecl() && type.instanceOf(this)) {
      return Optional.of(new Formula());
    }
    if (fullName().equals("java.lang.Object") && type.isInterfaceDecl()) {
      return Optional.of(new Formula());
    }
    if (isArrayDecl() && type.isArrayDecl()
        && elementType().verInstanceOf(type.elementType()).isPresent()) {
      return elementType().verInstanceOf(type.elementType());
    }
    return Optional.empty();
  }
}

aspect TypeWideningAndIdentity {

  /**
   *  Continue, used by the above attributes.
   */
  syn lazy Optional<Formula> TypeDecl.verInstanceOf(TypeDecl type);

  eq TypeDecl.verInstanceOf(TypeDecl type)
   = type == this ? Optional.of(new Formula()) : Optional.empty();

  eq ClassDecl.verInstanceOf(TypeDecl type) {
    if (isUncompiled()) {
      return type.verIsSupertypeOfClassDecl(this);
    }
    return instanceOf(type) ? Optional.of(new Formula()) : Optional.empty();
  }

  eq InterfaceDecl.verInstanceOf(TypeDecl type)
    = instanceOf(type) ? Optional.of(new Formula()) : Optional.empty();

  eq ArrayDecl.verInstanceOf(TypeDecl type) = type.verIsSupertypeOfArrayDecl(this);

  eq PrimitiveType.verInstanceOf(TypeDecl type)
    = type.isSupertypeOfPrimitiveType(this) ? Optional.of(new Formula()) : Optional.empty();

  eq UnknownType.verInstanceOf(TypeDecl type) = Optional.of(new Formula());

  syn Optional<Formula> TypeDecl.verIsSupertypeOfClassDecl(ClassDecl type) =
    type == this ? Optional.of(new Formula()) : Optional.empty();

  eq ClassDecl.verIsSupertypeOfClassDecl(ClassDecl type) {
    if (type == this) {
      return Optional.of(new Formula());
    }

    boolean okay = false;
    Formula formula = new Formula();

    for (TypeDecl check: type.superclassSet()) {
      Formula sub = new Formula();
      Optional<Formula> checkConstraint = check.verInstanceOf(this);
      if (checkConstraint.isPresent()) {
        if (check.version() != null) {
          sub = sub.multiply(type.getSuperClass().buildClause(check));
        }
        sub = sub.multiply(checkConstraint.get());
        formula = formula.add(sub);
        okay = true;
      }
    }

    return okay ? Optional.of(formula) : Optional.empty();
  }

  eq InterfaceDecl.verIsSupertypeOfClassDecl(ClassDecl type) {
    if (super.verIsSupertypeOfClassDecl(type).isPresent()) {
      return super.verIsSupertypeOfClassDecl(type);
    }

    for (InterfaceDecl iface: type.superInterfaces()) {
      if (iface.instanceOf(this)) {
        return Optional.of(new Formula());
      }
    }

    boolean okay = false;
    Formula formula = new Formula();

    for (TypeDecl check: type.superclassSet()) {
      Formula sub = new Formula();
      Optional<Formula> checkConstraint = check.verInstanceOf(this);
      if (checkConstraint.isPresent()) {
        if (check.version() != null) {
          sub = sub.multiply(type.getSuperClass().buildClause(check));
        }
        sub = sub.multiply(checkConstraint.get());
        formula = formula.add(sub);
        okay = true;
      }
    }

    return okay ? Optional.of(formula) : Optional.empty();
  }

  eq UnknownType.verIsSupertypeOfClassDecl(ClassDecl type) = Optional.of(new Formula());

  syn Optional<Formula> TypeDecl.verIsSupertypeOfArrayDecl(ArrayDecl type)
    = type == this ? Optional.of(new Formula()) : Optional.empty();

  eq ClassDecl.verIsSupertypeOfArrayDecl(ArrayDecl type) {
    if (super.verIsSupertypeOfArrayDecl(type).isPresent()) {
      return super.verIsSupertypeOfArrayDecl(type);
    }

    boolean okay = false;
    Formula formula = new Formula();

    for (TypeDecl check: type.superclassSet()) {
      Formula sub = new Formula();
      Optional<Formula> checkConstraint = check.verInstanceOf(this);
      if (checkConstraint.isPresent()) {
        if (check.version() != null) {
          sub = sub.multiply(type.getSuperClass().buildClause(check));
        }
        sub = sub.multiply(checkConstraint.get());
        formula = formula.add(sub);
        okay = true;
      }
    }

    return okay ? Optional.of(formula) : Optional.empty();
  }

  eq InterfaceDecl.verIsSupertypeOfArrayDecl(ArrayDecl type) {
    if (super.verIsSupertypeOfArrayDecl(type).isPresent()) {
      return super.verIsSupertypeOfArrayDecl(type);
    }
    for (InterfaceDecl iface: type.superInterfaces()) {
      if (iface.instanceOf(this)) {
        return Optional.of(new Formula());
      }
    }
    return Optional.empty();
  }

  eq ArrayDecl.verIsSupertypeOfArrayDecl(ArrayDecl type) {
    if (type.elementType().isPrimitive() && elementType().isPrimitive()) {
      if (type.dimension() == dimension() && type.elementType() == elementType()) {
        return Optional.of(new Formula());
      }
    }
    return type.componentType().verInstanceOf(componentType());
  }
}
