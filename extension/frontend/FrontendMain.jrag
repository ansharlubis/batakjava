aspect BatakjavaFrontendMain {

  public long Program.verErrorCheckTime;
  public long Program.constraintGenTime;
  public long Program.solvingTime;
  public long Program.javaGenTime;

  refine FrontendMain public void Program.resetStatistics() {
    javaParseTime = 0;
    bytecodeParseTime = 0;
    codeGenTime = 0;
    errorCheckTime = 0;
    numJavaFiles = 0;
    numClassFiles = 0;
    verErrorCheckTime = 0;
    constraintGenTime = 0;
    solvingTime = 0;
    javaGenTime = 0;
  }

  refine FrontendMain public void Program.printStatistics(PrintStream out) {
    out.println("javaParseTime: " + javaParseTime);
    out.println("bytecodeParseTime: " + bytecodeParseTime);
    out.println("codeGenTime: " + codeGenTime);
    out.println("errorCheckTime: " + errorCheckTime);
    out.println("numJavaFiles: " + numJavaFiles);
    out.println("numClassFiles: " + numClassFiles);
	out.println("verErrorCheckTime: " + verErrorCheckTime);
    out.println("constraintGenTime: " + constraintGenTime);
    out.println("solvingTime: " + solvingTime);
    out.println("javaGenTime: " + javaGenTime);
  }

  /**
   *  Frontend class for Batakjava, extended by the checker frontend
   */
  abstract public class BatakjavaFrontend extends Frontend {

    protected BatakjavaFrontend(String name, String version) {
      super(name, version);
    }

    @Override
    public int run(String[] args, BytecodeReader reader, JavaParser parser) {

      program.resetStatistics();
      program.initBytecodeReader(reader);
      program.initJavaParser(parser);

      initOptions();
      int argResult = processArgs(args);
      if (argResult != 0) {
        return argResult;
      }

      Collection<String> files = program.options().files();

      if (program.options().hasOption("-version")) {
        printVersion();
        return EXIT_SUCCESS;
      }

      if (program.options().hasOption("-help") || files.isEmpty()) {
        printUsage();
        return EXIT_SUCCESS;
      }

      try {
        for (String file: files) {
          program.addSourceFile(file);
        }

        TypeDecl object = program.lookupType("java.lang", "Object");
        if (object.isUnknown()) {
          System.err.println("Error: java.lang.Object is missing."
            + " The Java standard library was not found.");
          return EXIT_UNHANDLED_ERROR;
        }

        int compileResult = EXIT_SUCCESS;

        program.initializeInfVar();
        program.initializeInfType();

        for (CompilationUnit unit: program.getCompilationUnitList()) {
          int result = processVerCompilationUnit(unit);
          switch (result) {
            case EXIT_SUCCESS:
              break;
            case EXIT_UNHANDLED_ERROR:
              return result;
            default:
              compileResult = result;
          }
        }

        if (compileResult != EXIT_SUCCESS) {
          return compileResult;
        }

        if (program.solveConstraint() != EXIT_SUCCESS) {
          System.err.println("No solution found for the program");
        }

        // System.out.println("Type map: " + program.printInfTypeMap());

      } catch (Throwable t) {
        System.err.println("Fatal exception:");
        t.printStackTrace(System.err);
        return EXIT_UNHANDLED_ERROR;
      } finally {
        if (program.options().hasOption("-profile")) {
          program.printStatistics(System.out);
        }
      }

      return EXIT_SUCCESS;
    }

    /**
     *  Do type check on compilation units, while considering versions
     */
    protected int processVerCompilationUnit(CompilationUnit unit) throws Error {
      if (unit != null && unit.fromSource()) {
        try {
          Collection<Problem> errors = unit.parseErrors();
          Collection<Problem> warnings = Collections.emptyList();
          if (errors.isEmpty()) {
            long start = System.nanoTime();
            errors = unit.verErrors();
            warnings = unit.verWarnings();
            program.verErrorCheckTime += System.nanoTime() - start;
          }
          if (!errors.isEmpty()) {
            processErrors(errors, unit);
            return EXIT_ERROR;
          } else {
            if (!warnings.isEmpty() && !program.options().hasOption("-nowarn")) {
              processWarnings(warnings, unit);
            }
          }
        } catch (Error e) {
          System.err.println("Encountered error while processing " + unit.pathName());
          throw e;
        }
      }
      return EXIT_SUCCESS;
    }

  }

  // List of generated overview classes
  public java.util.List<CompilationUnit> Program.genOverview = new LinkedList();

  abstract public class BatakjavaBackend extends BatakjavaFrontend {

    protected Program genProgram;

    protected BatakjavaBackend(String name, String version) {
      super(name, version);
      genProgram = new Program();
      genProgram.state().reset();
    }

    @Override
    protected void initOptions() {
      super.initOptions();

      Options genOptions = genProgram.options();
      genOptions.addKeyValueOption("-d");
    }

    @Override
    public int run(String[] args, BytecodeReader reader, JavaParser parser) {

      program.resetStatistics();
      genProgram.resetStatistics();
      program.initBytecodeReader(reader);
      program.initJavaParser(parser);

      initOptions();
      int argResult = processArgs(args);
      genProgram.options().addOptions(args);
      if (argResult != 0) {
        return argResult;
      }

      Collection<String> files = program.options().files();

      if (program.options().hasOption("-version")) {
        printVersion();
        return EXIT_SUCCESS;
      }

      if (program.options().hasOption("-help") || files.isEmpty()) {
        printUsage();
        return EXIT_SUCCESS;
      }

      try {
        for (String file: files) {
          program.addSourceFile(file);
        }

        TypeDecl object = program.lookupType("java.lang", "Object");
        if (object.isUnknown()) {
          System.err.println("Error: java.lang.Object is missing."
            + " The Java standard library was not found.");
          return EXIT_UNHANDLED_ERROR;
        }

        int compileResult = EXIT_SUCCESS;

        program.initializeInfVar();
        program.initializeInfType();

        for (CompilationUnit unit: program.getCompilationUnitList()) {
          int result = processVerCompilationUnit(unit);
          switch (result) {
            case EXIT_SUCCESS:
              break;
            case EXIT_UNHANDLED_ERROR:
              return result;
            default:
              compileResult = result;
          }
        }

        if (compileResult != EXIT_SUCCESS) {
          return compileResult;
        }

        if (program.solveConstraint() != EXIT_SUCCESS) {
          System.out.println("Type map: " + program.printInfTypeMap());
          System.err.println("No solution found for the program");
          return compileResult;
        }

        long genStart = System.nanoTime();

        /** 
         *  Filter solutions based on field declarations 
         *
         *  NOTE: Getting all solutions from all options is impossible as the number of solutions
         *  can grow uncontrollable easily.
         */
        // java.util.List<Map<Integer,TypeDecl>> selectedSolutions = program.selectSolutions();
        Map<Integer,TypeDecl> selectedSolution = program.selectSolutions().iterator().next();

        /** Generate Java classes **/
        for (CompilationUnit unit: program.getCompilationUnitList()) {
          // CompilationUnit newUnit = unit.genJava(selectedSolutions);
          CompilationUnit newUnit = unit.genJava(selectedSolution);
          genProgram.addNewCompilationUnit(newUnit);
        }

        for (CompilationUnit newOverview: program.genOverview) {
          genProgram.addCompilationUnit(newOverview);
        }

        program.javaGenTime += System.nanoTime() - genStart;

        /** Initialize lookup **/
        object = genProgram.lookupType("java.lang", "Object");
        if (object.isUnknown()) {
          return EXIT_UNHANDLED_ERROR;
        }

        Collection<CompilationUnit> work = new LinkedList<CompilationUnit>();

        /* Debugging purpose
        for (CompilationUnit newUnit: genProgram.getCompilationUnitList()) {
          System.err.println(newUnit.prettyPrint());
        }
        */

        for (CompilationUnit newUnit: genProgram.getCompilationUnitList()) {
          work.add(newUnit);
          int result = processCompilationUnit(newUnit);
          switch (result) {
            case EXIT_SUCCESS:
              break;
            case EXIT_UNHANDLED_ERROR:
              return result;
            default:
              compileResult = result;
          }
        }

        for (CompilationUnit newUnit: work) {
          if (newUnit != null && newUnit.fromSource()) {
            long start = System.nanoTime();
            processNoErrors(newUnit);
            program.codeGenTime += System.nanoTime() - start;
          }
        }

      } catch (Throwable t) {
        System.err.println("Fatal exception:");
        t.printStackTrace(System.err);
        return EXIT_UNHANDLED_ERROR;
      } finally {
        if (program.options().hasOption("-profile")) {
          program.printStatistics(System.out);
        }
      }

      return EXIT_SUCCESS;
    }

  }
}