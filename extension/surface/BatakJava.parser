ImportDecl import_declaration =
    single_type_import_declaration_take
  | single_type_import_declaration_leave
  | type_import_on_demand_declaration_take
  | type_import_on_demand_declaration_leave
  ;
ImportDecl single_type_import_declaration_take =
    IMPORT name TAKE VER version_numbers.vl SEMICOLON
    {: return new SingleTypeImportDeclTake(name, vl); :}
  ;
ImportDecl single_type_import_declaration_leave =
    IMPORT name LEAVE VER version_numbers.vl SEMICOLON
    {: return new SingleTypeImportDeclLeave(name, vl); :}
  ;
ImportDecl type_import_on_demand_declaration_take =
    IMPORT name DOT MULT TAKE VER version_numbers.vl SEMICOLON
    {: return new TypeImportOnDemandDeclTake(name, vl); :}
  ;
ImportDecl type_import_on_demand_declaration_leave =
    IMPORT name DOT MULT LEAVE VER version_numbers.vl SEMICOLON
    {: return new TypeImportOnDemandDeclLeave(name, vl); :}
  ;
TypeDecl type_declaration =
    version_class_declaration
  ;
TypeDecl version_class_declaration =
    modifiers.m CLASS IDENTIFIER VER version_number.v super.s? interfaces.i? class_body.b
    {: return new VersionClassDecl(new Modifiers(m), IDENTIFIER, s, i, b, new Version(v)); :}
  ;
Access class_or_interface_type =
    name.n SHARP version_numbers.vs SHARP
    {: return new VersionTypeAccess(n, vs); :}
  ;
Expr class_instance_creation_expression =
    NEW name.n SHARP version_numbers.vs SHARP LPAREN argument_list.l? RPAREN
    {: return new ClassInstanceExpr(new VersionTypeAccess(n, vs), l, new Opt()); :}
  ;
Expr cast_expression =
    LPAREN name.t LBRACE version_numbers.vs RBRACE RPAREN unary_expression_not_plus_minus.e @CAST
    {: return new CastExpr(new VersionTypeAccess(t, vs), e); :}
  ;
List version_numbers =
    version_number.v                            {: return new List().add(new Version(v)); :}
  | version_numbers.vs COMMA version_number.v   {: return vs.add(new Version(v)); :}
  ;
String version_number =
    NUMERIC_LITERAL
  ;